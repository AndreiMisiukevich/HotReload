import org.apache.tools.ant.taskdefs.condition.Os

buildscript {
    repositories {
        maven { url 'https://www.myget.org/F/rd-snapshots/maven/' }
        mavenCentral()
    }

    dependencies {
        classpath("com.jetbrains.rd:rd-gen:0.193.119")
        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.31")
    }
}

plugins {
    id 'java'
    id 'org.jetbrains.kotlin.jvm' version '1.3.41'
    id 'org.jetbrains.intellij' version '0.4.21'
}

ext {
    repoRoot = projectDir
    pluginVersion = '1.4.3'
    // https://www.jetbrains.com/intellij-repository/snapshots - link to repo of RD snapshots
    ProductVersion = "${productVersion}-SNAPSHOT"
    isWindows = Os.isFamily(Os.FAMILY_WINDOWS)
    rdLibDirectory = new File(repoRoot, "build/riderRD-${ProductVersion}/lib/rd")
    dotNetDir = new File(repoRoot, "src/dotnet")
    dotNetPluginId = "Xamarin.Forms.HotReload.Extension.Rider"
    dotnetSolution = new File(repoRoot, "Xamarin.Forms.HotReload.Extension.Rider.sln")
}

repositories {
    maven { url 'https://cache-redirector.jetbrains.com/intellij-repository/snapshots' }
    maven { url 'https://cache-redirector.jetbrains.com/maven-central' }
    flatDir { dirs rdLibDirectory.absolutePath }
}

wrapper {
    gradleVersion = '4.9'
    distributionType = Wrapper.DistributionType.ALL
    distributionUrl = "https://cache-redirector.jetbrains.com/services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
}

if (!ext.has("BuildConfiguration"))
    ext.BuildConfiguration = "Release"

if (ext.has("pluginVersion"))
    ext.version = ext.pluginVersion

version ext.version

sourceSets {
    main {
        java.srcDir 'src/rider/main/kotlin'
        resources.srcDir 'src/rider/main/resources'
    }
}

compileKotlin {
    kotlinOptions { jvmTarget = "1.8" }
}

intellij {
    type = 'RD'
    //Only one of the arguments `version` or `localPath` should be passes in a time
    //localPath = 'HERE SHOULD BE PATH TO YOUR LOCAL RIDER'
    version = "${ProductVersion}"
    downloadSources = false
}

def riderSdkPackageVersion = {
    def sdkPath = new File(repoRoot, "/build/riderRD-$ProductVersion")
    def path = new File(sdkPath, "lib/ReSharperHostSdk")
    if (!path.isDirectory()) error("$path does not exist or not a directory")

    def sdkPackageName = "JetBrains.Rider.SDK"

    def regex = "${sdkPackageName}\\.([\\d\\.]+.*)\\.nupkg"
    def matchingPackage = path.list().find{ it =~ regex}
    def groups = matchingPackage =~ regex
    return groups[0][1]
}

task compileDotNet {
    def riderSdkVersionPropsPath = new File(dotNetDir, "SdkVersion.props")
    def version = "2019.3.0-*"

//  ToDo: Better to use in future def version = riderSdkPackageVersion()
    riderSdkVersionPropsPath.text = ''
    riderSdkVersionPropsPath << "<Project>\n"
    riderSdkVersionPropsPath << "   <PropertyGroup>\n"
    riderSdkVersionPropsPath << "     <SdkVersion>${version}</SdkVersion>\n"
    riderSdkVersionPropsPath << "  </PropertyGroup>\n"
    riderSdkVersionPropsPath << " </Project>\n"

    doLast {
        exec {
            boolean isUnix = Os.isFamily(Os.FAMILY_UNIX)
            if (isUnix) {
                environment "FrameworkPathOverride", "/usr/lib/mono/4.5"
            }

            executable "dotnet"
            args "msbuild", "/t:Restore;Rebuild", "$dotnetSolution", "/p:Configuration=$BuildConfiguration"
            workingDir rootDir
        }
    }
}

buildPlugin {
    outputs.upToDateWhen { false }
    doLast {
        copy {
            from "$buildDir/distributions/$rootProject.name-${version}.zip"
            into "$rootDir/output"
        }

        def changelogText = file("$repoRoot/CHANGELOG.md").text
        def changelogMatches = changelogText =~ /(?s)(-.+?)(?=##|$)/
        def changeNotes = changelogMatches.collect {
            it[1].replaceAll(/(?s)- /, "\u2022 ").replaceAll(/`/, "").replaceAll(/,/, "%2C")
        }.take(1).join("")

        exec {
            executable "dotnet"
            args "msbuild", "/t:Pack", "$dotnetSolution", "/p:Configuration=$BuildConfiguration", "/p:PackageOutputPath=$rootDir/output", "/p:PackageReleaseNotes=$changeNotes", "/p:PackageVersion=$version"
        }
    }
}

apply plugin: 'com.jetbrains.rdgen'

rdgen {
    def modelDir = new File(repoRoot, "protocol/src/main/kotlin/model")
    def csOutput = new File(repoRoot, "src/dotnet/Xamarin.Forms.HotReload.Extension.Rider/Model")
    def ktOutput = new File(repoRoot, "src/rider/main/kotlin/hotreload.extension.rider/model")

    verbose = true
    classpath "$rdLibDirectory/rider-model.jar"
    sources "$modelDir/rider"
    hashFolder = 'build/rdgen/rider'
    packages = "model.rider"

    generator {
        language = "kotlin"
        transform = "asis"
        root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
        namespace = "com.jetbrains.rider.model"
        directory = "$ktOutput"
    }

    generator {
        language = "csharp"
        transform = "reversed"
        root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
        namespace = "JetBrains.Rider.Model"
        directory = "$csOutput"
    }
}

patchPluginXml {
    sinceBuild = '201.0'
    untilBuild = '*.*'
    def changelogText = file("$repoRoot/CHANGELOG.md").text
    def changelogMatches = changelogText =~ /(?s)(-.+?)(?=##|$)/

    changeNotes = changelogMatches.collect {
        it[1].replaceAll(/(?s)\r?\n/, "<br />\n")
    }.take(1).join('')
}

prepareSandbox {
    dependsOn compileDotNet

    def rootExtFolder = file("$projectDir/..").getAbsolutePath()

    def coreExtId = "Xamarin.Forms.HotReload.Extension"
    def coreExtOutputFolder = "$rootExtFolder/$coreExtId/bin/$BuildConfiguration/net472"
    def outputFolder = "$dotNetDir/$dotNetPluginId/bin/${dotNetPluginId}/$BuildConfiguration"
    def dllFiles = [
            "$outputFolder/${dotNetPluginId}.dll",
            "$outputFolder/${dotNetPluginId}.pdb",
            "$coreExtOutputFolder/${coreExtId}.dll",
            "$coreExtOutputFolder/${coreExtId}.pdb"
    ]

    dllFiles.forEach({ f ->
        def file = file(f)
        from(file, { into "$intellij.pluginName/dotnet" })
    })

    doLast {
        dllFiles.forEach({ f ->
            def file = file(f)
            if (!file.exists()) throw new RuntimeException("File $file does not exist")
        })
    }
}